<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="JSP九个内置对象 request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Jav">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE面试题">
<meta property="og:url" content="http://yoursite.com/2020/03/03/JavaSE%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="YoXn&#39;s Blog">
<meta property="og:description" content="JSP九个内置对象 request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Jav">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://camo.githubusercontent.com/3a68153ce17be90275df07a47409afaea91aff83/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f536c6563746f722e706e67">
<meta property="og:image" content="https://img-blog.csdn.net/20160924191851607">
<meta property="article:published_time" content="2020-03-03T13:50:35.000Z">
<meta property="article:modified_time" content="2020-03-17T16:39:29.968Z">
<meta property="article:tag" content="反射">
<meta property="article:tag" content="注解">
<meta property="article:tag" content="内部类">
<meta property="article:tag" content="IO">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://camo.githubusercontent.com/3a68153ce17be90275df07a47409afaea91aff83/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f536c6563746f722e706e67">

<link rel="canonical" href="http://yoursite.com/2020/03/03/JavaSE%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>JavaSE面试题 | YoXn's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YoXn's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/JavaSE%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="Enjoy when you can,and endure when you must.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YoXn's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaSE面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-03 21:50:35" itemprop="dateCreated datePublished" datetime="2020-03-03T21:50:35+08:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-18 00:39:29" itemprop="dateModified" datetime="2020-03-18T00:39:29+08:00">2020-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">Java面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="JSP九个内置对象"><a href="#JSP九个内置对象" class="headerlink" title="JSP九个内置对象"></a>JSP九个内置对象</h3><ul>
<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面本身（相当于Java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<hr>
 <a id="more"></a>

<h3 id="Cookie和Session的的区别"><a href="#Cookie和Session的的区别" class="headerlink" title="Cookie和Session的的区别"></a>Cookie和Session的的区别</h3><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> </p>
<p>①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；</p>
<p>②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；</p>
<p>③登录一次网站后访问网站其他页面不需要重新登录。</p>
<p><strong>Session 的主要作用就是通过服务端记录用户的状态。</strong></p>
<p>典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<p><strong>session机制</strong>：</p>
<p>客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；<br>并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);<br>服务端也会产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；<br>然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；<br>因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）</p>
<p>客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID  去服务端的session中匹配sessionid,如果匹配成功（cookie  jsessionid和sesion sessionid），说明此用户 不是第一次访问,无需登录；</p>
<hr>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><p><strong>单例模式</strong></p>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。 </p>
</li>
<li><p><strong>工厂模式</strong></p>
<p>在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。 </p>
</li>
<li><p><strong>代理模式</strong></p>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
</li>
<li><p><strong>策略模式</strong></p>
<p>定义一系列的算法，把每一个算法封装起来，并且使它们可以相互替换。这个模式中使得各个算法可以独立于使用它的客户而变化。<br>策略模式的构成：<br>1.抽象策略角色：策略类，通常由一个接口或者抽象类实现。<br>2.具体策略角色：包装了相关的算法和行为，实现策略接口或继承抽象类。<br>3.环境角色：context，运行时持有一个策略类的引用，最终给客户端调用。</p>
<p>策略模式让算法独立于使用它的客户而独立变化。策略模式重点是封装不同的算法和行为，不同的场景下可以相互替换。策略模式是开闭原则的体现，开闭原则讲的是一个软件实体应该对拓展开放对修改关闭。因为策略模式在加入新的策略时，不会影响其他类的修改，增加了拓展性，也就是对拓展是开放的；对于调用场景来说，只依赖于抽象，而不依赖于具体实现，所以对修改是关闭的。<br>策略模式的优点和缺点<br>优点：<br>（1）调用策略中的方法在context中，没有和各个策略的实现耦合在一起，各个实现策略的不同子类可以去拓展、修改和切换。<br>（2）避免写很多if else代码，提高了可观性。同时可以结合抽象类（策略类）去使用，Java支持很好。<br>缺点：<br>（1）客户端调用时必须知道所有的策略类，并且感知到要调用哪一种策略实现。<br>（2）一旦抽象，必然会对一些特殊场景难以处理。并且这里去加入了很多的策略实现类，也有Context类的加入，增加了开销。</p>
</li>
<li><p><strong>模板模式</strong></p>
<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 </p>
</li>
<li><p><strong>观察者模式</strong></p>
<p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。</p>
</li>
<li><p><strong>适配器模式</strong></p>
<p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Spring 框架中用到了哪些设计模式？</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Java-反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？"><a href="#Java-反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？" class="headerlink" title="Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？"></a>Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</h3><ol>
<li><p>JAVA反射机制是在运行状态中，<strong>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性</strong>；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
</li>
<li><p><strong>优点</strong>：</p>
<p>可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中，它的灵活性就表现的十分明显。</p>
<p>比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了。</p>
<p>当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。</p>
<p>采用静态的话，需要把整个程序重新编译一次才可以实现功能 的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</p>
<p><strong>缺点</strong>：</p>
<p>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</p>
</li>
<li><p><strong>原理</strong></p>
<p>反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成相应的Method、Filed、Constructor等类 </p>
</li>
</ol>
<hr>
<h3 id="谈谈对-Java-注解的理解，解决了什么问题？"><a href="#谈谈对-Java-注解的理解，解决了什么问题？" class="headerlink" title="谈谈对 Java 注解的理解，解决了什么问题？"></a>谈谈对 Java 注解的理解，解决了什么问题？</h3><ol>
<li>jdk 5.0 新增的功能</li>
<li>Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载,运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。</li>
<li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li>
</ol>
<hr>
<h3 id="内部类了解吗？匿名内部类了解吗？"><a href="#内部类了解吗？匿名内部类了解吗？" class="headerlink" title="内部类了解吗？匿名内部类了解吗？"></a>内部类了解吗？匿名内部类了解吗？</h3><ol>
<li><p>定义：Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。</p>
</li>
<li><p>内部类的分类：<br>成员内部类（静态、非静态 ） vs 局部内部类(方法内、代码块内、构造器内)。</p>
</li>
<li><p>成员内部类的理解：<br>一方面，作为外部类的成员：调用外部类的结构；可以被static修饰；可以被4种不同的权限修饰。</p>
<p>另一方面，作为一个类：类内可以定义属性、方法、构造器等；可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承；可以被abstract修饰。</p>
</li>
<li><p>分类<br>4.1 静态内部类：作为类的静态成员，存在于某个类的内部。<br>4.2 成员内部类：作为类的成员，存在于某个类的内部。<br>4.3 局部内部类：存在于某个方法的内部。<br>4.4 匿名内部类：存在于某个类的内部，但是无类名的类。</p>
</li>
</ol>
<hr>
<h3 id="BIO和NIO区别-4核cpu，100个http连接，用BIO和NIO分别需要多少个线程"><a href="#BIO和NIO区别-4核cpu，100个http连接，用BIO和NIO分别需要多少个线程" class="headerlink" title="BIO和NIO区别,4核cpu，100个http连接，用BIO和NIO分别需要多少个线程"></a>BIO和NIO区别,4核cpu，100个http连接，用BIO和NIO分别需要多少个线程</h3><ol>
<li>BIO（同步阻塞）：每一个IO请求都会有一个线程去处理，如果数据没有准备就绪，线程会一直等待。直到数据读取完毕线程才会释放，在此期间，进程不回去做任何其他任务，这种模式会浪费一定的线程资源。</li>
<li>NIO（同步非阻塞）：NIO的优点在于首先基于缓存读写文件，能够批量操作，然后用channel双向读写数据，减少每次打开断开流的资源消耗。引入selecore的概念，用一个线程管理多个通道，大大减少线程开销。</li>
</ol>
<hr>
<h3 id="假如我们需要存500个数需要多大的HashMap？"><a href="#假如我们需要存500个数需要多大的HashMap？" class="headerlink" title="假如我们需要存500个数需要多大的HashMap？"></a>假如我们需要存500个数需要多大的HashMap？</h3><hr>
<h3 id="自定义注解-应用场景"><a href="#自定义注解-应用场景" class="headerlink" title="自定义注解 应用场景"></a>自定义注解 应用场景</h3><p><strong>自定义注解：</strong></p>
<ul>
<li><p>① 注解声明为：@interface</p>
<ul>
<li>② 内部定义成员，通常使用value表示</li>
<li>③ 可以指定成员的默认值，使用default定义</li>
<li>④ 如果自定义注解没成员，表明是一个标识作用。</li>
</ul>
</li>
</ul>
<p><strong>说明：</strong><br>如果注解有成员，在使用注解时，需要指明成员的值。<br>自定义注解必须配上注解的信息处理流程(使用反射)才意义。<br>自定义注解通常都会指明两个元注解：Retention、Target</p>
<p><strong>代码举例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Inherited</span><br><span class="line">@Repeatable(MyAnnotations.class)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String value() default &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元注解 ：对现有的注解进行解释说明的注解。</strong><br>jdk 提供的4种元注解：<br><strong>Retention</strong>：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为\RUNTIME） 只声明为RUNTIME生命周期的注解，才能通过反射获取。<br><strong>Target</strong>:用于指定被修饰的 Annotation 能用于修饰哪些程序元素。<br><strong>Documented:</strong>表示所修饰的注解在被javadoc解析时，保留下来。<br><strong>Inherited</strong>:被它修饰的 Annotation 将具继承性。</p>
<p>—&gt;类比：元数据的概念：String name = “Tom”;</p>
<p><strong>应用场景:</strong></p>
<p>示例一：生成文档相关的注解</p>
<p>示例二：在编译时进行格式检查(JDK内置的个基本注解)<br>                @Override: 限定重写父类方法, 该注解只能用于方法<br>                @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修                饰的结构危险或存在更好的选择<br>                @SuppressWarnings: 抑制编译器警告</p>
<hr>
<h3 id="Java-面向对象编程三大特性-封装-继承-多态"><a href="#Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="Java 面向对象编程三大特性: 封装 继承 多态"></a>Java 面向对象编程三大特性: 封装 继承 多态</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<hr>
<p>###动态代理</p>
<p>动态代理具体步骤：</p>
<ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ol>
<hr>
<h3 id="BIO、NIO和AIO总结"><a href="#BIO、NIO和AIO总结" class="headerlink" title="BIO、NIO和AIO总结"></a>BIO、NIO和AIO总结</h3><p><strong>同步</strong> ：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在A-&gt;B事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用种被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</p>
<p><strong>异步</strong>： 两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，</p>
<p><strong>阻塞</strong>： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</p>
<p><strong>非阻塞</strong>： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</p>
<ul>
<li><p>BIO</p>
<p>同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。 </p>
</li>
<li><p>NIO</p>
<p>NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。</p>
<p><strong>IO流是阻塞的，NIO流是不阻塞的。</strong></p>
<p>Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用 <code>read()</code> 或 <code>write()</code> 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了</p>
<p><strong>Buffer(缓冲区)</strong></p>
<p><strong>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</strong></p>
<p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p>
<p>在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
<p>最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</p>
<p><strong>Channel (通道)</strong></p>
<p>NIO 通过Channel（通道） 进行读写。</p>
<p>通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</p>
<p><strong>Selector</strong> <strong>(选择器)</strong></p>
<p>NIO有选择器，而IO没有。</p>
<p>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</p>
<p><a href="https://camo.githubusercontent.com/3a68153ce17be90275df07a47409afaea91aff83/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f536c6563746f722e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3a68153ce17be90275df07a47409afaea91aff83/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f536c6563746f722e706e67" alt="一个单线程中Selector维护3个Channel的示意图"></a></p>
</li>
</ul>
<p>SpringAOP实现原理+IOC实现原理(源码怎么实现)？</p>
<p>10.并发时怎么应对？<br>11.OM平时用过吗？怎么解决OM？</p>
<p>12.讲一讲线程创建的时候发生了什么？</p>
<p>第一面：<br>1.多线程和多进程分别适用于什么场景？<br>2.并发和并行的区别？<br>3.TCP/IP协议的3次握手和4次挥手？原因？<br>4.设计平衡二叉树的原因？<br>5.快排、堆排、归并等排序的时间复杂度与空间复杂度？</p>
<p> <img src="https://img-blog.csdn.net/20160924191851607" alt="这里写图片描述"> </p>
<p>6.索引的数据结构有哪些，讲一讲B+树？<br>7.MySQL的存储引擎知道吗？区别？<br>8.合并两个有序表最优解（当时只想到了归并排序的思想双指针外排序方式）<br>9.介绍HashMap，说到红黑树，然后提问：介绍一下红黑树？</p>
<p>第二面：<br>1.介绍堆的数据结构和堆排序的思路，并手写堆排序代码（10分钟）<br>2.场景题：只有一台机器，10亿个ip地址（有重复）找出出现最多的10个ip，怎么处理？<br>3.HashMap冲突的解决方法以及原理分析？<br>4.Git的常用命令有哪些，merge时候出现冲突怎么处理？</p>
<p>记录了一些出现比较多的面试的问题（套路）：</p>
<p>1.面向对象的特性？<br>2.讲一讲Java多态？<br>3.抽象类与接口的区别？<br>4.讲一讲HashMap？<br>5.Java线程池好处以及实现原理？怎么创建线程池？<br>6.Java8新特性了解吗？，讲一讲流？<br>7.闭包了解吗？讲一讲lambda表达式？<br>8.比较Java锁(synchronized和ReentrantLock的区别)？<br>9.讲一讲JVM里面的GC？<br>10.JVM内存分配策略？<br>11.反射是什么，怎么实现的？<br>12.讲一讲事务的特性？解释一下ACID分别是什么？<br>13.知道哪些设计模式？平时或者项目里面用过哪些设计模式？<br>14.手写单例模式（双重检测机制）<br>15.MySQL 中 InnoDB 和 MyISAM 区别？<br>16.MySQL的默认隔离级别？<br>17.知道数据库优化吗？SQL优化？<br>18.讲一讲索引，说一说B+树<br>19.什么是SQL注入？怎么解决？<br>20.用过哪些SQL的函数？（写一个查找平均分SQL语句）<br>21.讲一讲spring事务，ioc，aop，bean声明周期？<br>22.hibernate和mybatis的区别，各自的优缺点<br>23.Linux常用命令有哪些，查看端口的命令是什么？<br>24.HTTP常用的首部字段有哪些？<br>25.GET和POST的区别？<br>26.HTTPS协议？什么是对称加密和非对称加密？<br>27.多线程join()和yield()方法的作用？<br>28.介绍一下juc里面常用的几个工具类<br>29.TCP/IP协议的3次握手和4次挥手<br>30.各种排序算法思路以及时间复杂度（主要是快排，冒泡，堆排，归并）<br>31.topk问题（快排和堆来解决）<br>32.Git的常用命令有哪些？<br>33.Git在merge的时候出现冲突，怎么处理冲突？</p>
<p><strong>基础：</strong></p>
<ol>
<li>Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</li>
<li>谈谈对 Java 注解的理解，解决了什么问题？</li>
<li>内部类了解吗？匿名内部类了解吗？</li>
<li>BIO和NIO区别,4核cpu，100个http连接，用BIO和NIO分别需要多少个线程</li>
<li>假如我们需要存500个数需要多大的HashMap？</li>
<li>HashMap的负载因子。</li>
</ol>
<p><strong>jvm:</strong></p>
<ol>
<li>jvm 内存结构</li>
<li>jvm 调优参数</li>
<li>什么是类加载？</li>
<li>何时类加载？</li>
<li>java的类加载流程？</li>
<li>知道哪些类加载器。类加载器之间的关系？</li>
<li>类加载器之间的关系？</li>
<li><strong>类加载器的双亲委派</strong> （结合tomcat说一下双亲委派）</li>
<li><strong>为什么需要双亲委派</strong></li>
<li>Java内存模型</li>
<li>栈中存放什么数据，堆中呢？</li>
<li>大对象放在哪个内存区域</li>
<li>堆区如何分类</li>
<li>垃圾回收有哪些算法</li>
<li>GC的全流程</li>
<li>GC中老年代用什么回收方法？</li>
</ol>
<p><strong>多线程：</strong></p>
<ol>
<li><strong>Java线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？</strong></li>
<li>死锁</li>
</ol>
<p><strong>设计模式：</strong></p>
<ol>
<li>阅读Spring源码的时候什么设计模式最让你影响深刻？如何使用？</li>
<li>单例模式，单例模式的使用场景</li>
<li>观察者模式，观察者模式的使用场景</li>
</ol>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ol>
<li>spring boot和spring的区别</li>
<li>ioc 和 aop(ioc流程、aop实现原理)、spring aop异常处理、当一段代码被try catch后再发生异常时，aop的异常通知是否执行，为什么？</li>
<li>spring bean的生命周期说一下</li>
<li>spring data jpa底层是什么？</li>
<li>hibernate和mybatis区别</li>
<li>spring boot 过滤器</li>
<li>spring boot 拦截器</li>
<li>Spring动态代理默认用哪一种</li>
<li>写出spring jdk动态代理的实现。</li>
<li>画出spring boot处理一个http请求的全过程</li>
</ol>
<p><strong>推荐</strong></p>
<ol>
<li>手写实现Spring核心功能：<a href="https://github.com/jinzzzzz/spring-demo" target="_blank" rel="noopener">https://github.com/jinzzzzz/spring-demo</a></li>
</ol>
<h3 id="微服务-分布式"><a href="#微服务-分布式" class="headerlink" title="微服务/分布式"></a>微服务/分布式</h3><ol>
<li>为什么要网关？</li>
<li>限流的算法有哪些？</li>
<li>为什么要分布式 id ？分布式 id 生成策略有哪些？</li>
<li>了解RPC吗？有哪些常见的 RPC 框架？</li>
<li>如果让你自己设计 RPC 框架你会如何设计？</li>
<li>Dubbo 了解吗？Spring Cloud 了解吗？</li>
</ol>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ol>
<li>非关系型数据库和关系型数据库的区别？</li>
<li><strong>事务的四大特性</strong></li>
<li><strong>MySQL 事务隔离级别？默认是什么级别？</strong></li>
<li><strong>乐观锁与悲观锁的区别</strong></li>
<li>数据库两种存储引擎的区别</li>
<li>最左前缀匹配原则及它的原因</li>
<li>大表优化的思路</li>
<li><strong>where和having的区别</strong></li>
<li>分库分表</li>
<li><strong>explain 命令</strong></li>
</ol>
<p><strong>索引</strong></p>
<ol>
<li><strong>如何加快数据库查询速度</strong></li>
<li><strong>聚集索引和非聚集索引的区别</strong></li>
<li><strong>什么时候不该使用索引？</strong></li>
<li><strong>索引底层的数据结构？</strong></li>
<li><strong>B+树做索引比红黑树好在哪里？</strong></li>
<li></li>
</ol>
<p><strong>Redis:</strong></p>
<ol>
<li>项目中 redis 是怎么用的？解决了什么问题？</li>
<li>说一下有缓存情况下查询的流程以及有缓存情况下修改的流程。</li>
<li>redis有哪些数据结构</li>
<li>redis内存满了怎么办</li>
<li>redis内存淘汰算法除了lru还有哪些</li>
<li>分布式缓存可能出现的问题</li>
<li>缓存穿透问题</li>
</ol>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ol>
<li><strong>计算机网络的一些常见状态码</strong></li>
<li>ping 所使用的协议</li>
<li><strong>TCP的三次握手与四次挥手的内容</strong></li>
<li><strong>TCP为什么连接是三次握手而断开是四次握手</strong></li>
<li>TCP与UDP的区别及使用场景</li>
<li><strong>一次完整的HTTP请求所经的步骤</strong></li>
<li>http 如何保存登录信息(没太搞懂意思)</li>
<li><strong>Cookie 和 Session的关系</strong></li>
</ol>
<h3 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h3><p><strong>算法</strong></p>
<ol>
<li>LRU 算法了解吗？你能实现一个吗？</li>
<li>写排序算法（快排、堆排）</li>
</ol>
<p><strong>数据结构</strong></p>
<ol>
<li>布隆过滤器了解吗？</li>
</ol>
<h3 id="设计题"><a href="#设计题" class="headerlink" title="设计题"></a>设计题</h3><ol>
<li>假如有10亿个数，只有一个重复，内存只能放下5亿个数，怎么找到这个重复的数字？</li>
<li>如何设计一个秒杀系统（服务端、数据库、分布式）？分布式系统的设计？</li>
<li>有一个服务器专门接收大量请求，怎么设计？</li>
<li>如果让你自己设计 RPC 框架你会如何设计？</li>
<li>怎么快速出现一个stackoverflow错误？</li>
</ol>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol>
<li>自我介绍。</li>
<li>说说你的项目中的亮点有哪些。</li>
<li>画一下你的项目的架构图。</li>
<li><strong>Restful 了解吗？简单说一下自己对它的认识，如果我要返回一个 boolean 类型的数据怎么办？</strong></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag"># 反射</a>
              <a href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag"># 注解</a>
              <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag"># 内部类</a>
              <a href="/tags/IO/" rel="tag"># IO</a>
              <a href="/tags/HashMap/" rel="tag"># HashMap</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/03/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="next" title="数据结构">
      数据结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#JSP九个内置对象"><span class="nav-number">1.</span> <span class="nav-text">JSP九个内置对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie和Session的的区别"><span class="nav-number">2.</span> <span class="nav-text">Cookie和Session的的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计模式"><span class="nav-number">3.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">3.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？"><span class="nav-number">4.</span> <span class="nav-text">Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谈谈对-Java-注解的理解，解决了什么问题？"><span class="nav-number">5.</span> <span class="nav-text">谈谈对 Java 注解的理解，解决了什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类了解吗？匿名内部类了解吗？"><span class="nav-number">6.</span> <span class="nav-text">内部类了解吗？匿名内部类了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO和NIO区别-4核cpu，100个http连接，用BIO和NIO分别需要多少个线程"><span class="nav-number">7.</span> <span class="nav-text">BIO和NIO区别,4核cpu，100个http连接，用BIO和NIO分别需要多少个线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#假如我们需要存500个数需要多大的HashMap？"><span class="nav-number">8.</span> <span class="nav-text">假如我们需要存500个数需要多大的HashMap？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义注解-应用场景"><span class="nav-number">9.</span> <span class="nav-text">自定义注解 应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-面向对象编程三大特性-封装-继承-多态"><span class="nav-number">10.</span> <span class="nav-text">Java 面向对象编程三大特性: 封装 继承 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#封装"><span class="nav-number">10.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承"><span class="nav-number">10.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态"><span class="nav-number">10.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO、NIO和AIO总结"><span class="nav-number">11.</span> <span class="nav-text">BIO、NIO和AIO总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring"><span class="nav-number">12.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微服务-分布式"><span class="nav-number">13.</span> <span class="nav-text">微服务&#x2F;分布式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库"><span class="nav-number">14.</span> <span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络"><span class="nav-number">15.</span> <span class="nav-text">网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法和数据结构"><span class="nav-number">16.</span> <span class="nav-text">算法和数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计题"><span class="nav-number">17.</span> <span class="nav-text">设计题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他问题"><span class="nav-number">18.</span> <span class="nav-text">其他问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">Enjoy when you can,and endure when you must.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
